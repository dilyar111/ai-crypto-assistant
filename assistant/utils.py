import streamlit as st
from typing import Any, Optional
import pandas as pd
from datetime import datetime, timedelta

def format_currency(value: Any) -> str:
    """Format currency values with appropriate suffixes"""
    if not isinstance(value, (int, float)) or value == 0:
        return "0"
    
    if value >= 1_000_000_000_000:  # Trillions
        return f"{value / 1_000_000_000_000:.2f}T"
    elif value >= 1_000_000_000:  # Billions
        return f"{value / 1_000_000_000:.2f}B"
    elif value >= 1_000_000:  # Millions
        return f"{value / 1_000_000:.2f}M"
    elif value >= 1_000:  # Thousands
        return f"{value / 1_000:.2f}K"
    elif value >= 1:
        return f"{value:.2f}"
    else:
        return f"{value:.6f}"

def format_percentage(value: Any) -> str:
    """Format percentage values"""
    if not isinstance(value, (int, float)):
        return "0.00"
    return f"{value:.2f}"

def format_supply(value: Any) -> str:
    """Format supply values"""
    if not isinstance(value, (int, float)) or value == 0:
        return "0"
    
    if value >= 1_000_000_000_000:
        return f"{value / 1_000_000_000_000:.2f}T"
    elif value >= 1_000_000_000:
        return f"{value / 1_000_000_000:.2f}B"
    elif value >= 1_000_000:
        return f"{value / 1_000_000:.2f}M"
    elif value >= 1_000:
        return f"{value / 1_000:.2f}K"
    else:
        return f"{value:,.0f}"

def get_price_color(change: float) -> str:
    """Get color for price change display"""
    if change > 0:
        return "ðŸŸ¢"
    elif change < 0:
        return "ðŸ”´"
    else:
        return "âšª"

def calculate_price_change_emoji(change_24h: float) -> str:
    """Get emoji based on price change"""
    if change_24h > 5:
        return "ðŸš€"
    elif change_24h > 1:
        return "ðŸ“ˆ"
    elif change_24h > 0:
        return "ðŸŸ¢"
    elif change_24h == 0:
        return "âž–"
    elif change_24h > -1:
        return "ðŸ”´"
    elif change_24h > -5:
        return "ðŸ“‰"
    else:
        return "ðŸ’¥"

def create_price_chart_data(price_data: dict, market_data: dict) -> Optional[pd.DataFrame]:
    """Create sample chart data (would need historical data API)"""
    # This is a placeholder - in real implementation, you'd fetch historical data
    try:
        current_price = float(price_data.get('price', 0))
        if current_price == 0:
            return None
        
        # Generate sample data for demonstration
        dates = pd.date_range(end=datetime.now(), periods=30, freq='D')
        # Simple random walk for demo (replace with real historical data)
        import random
        prices = []
        base_price = current_price
        for i in range(30):
            change = random.uniform(-0.1, 0.1)
            base_price = base_price * (1 + change)
            prices.append(base_price)
        
        return pd.DataFrame({
            'Date': dates,
            'Price': prices
        })
    except Exception:
        return None

def display_error_message(error_type: str, details: str = ""):
    """Display formatted error messages"""
    error_messages = {
        "api_error": "ðŸ”Œ API connection failed",
        "data_error": "ðŸ“Š Data processing error", 
        "token_error": "ðŸ” Token not recognized",
        "model_error": "ðŸ¤– AI model unavailable"
    }
    
    message = error_messages.get(error_type, "âŒ Unknown error")
    st.error(f"{message}")
    
    if details:
        with st.expander("Error Details"):
            st.code(details)

def display_success_message(message: str):
    """Display formatted success messages"""
    st.success(f"âœ… {message}")

def display_warning_message(message: str):
    """Display formatted warning messages"""
    st.warning(f"âš ï¸ {message}")

def display_info_message(message: str):
    """Display formatted info messages"""
    st.info(f"â„¹ï¸ {message}")

def create_download_content(token_info: dict, market_data: dict, price_data: dict, ai_response: str) -> str:
    """Create downloadable content"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    content = f"""
# {token_info['name']} ({token_info['symbol']}) Analysis Report
Generated on: {timestamp}

## Market Data
- Current Price: ${format_currency(price_data.get('price', 0))}
- 24h Change: {format_percentage(price_data.get('change_24h', 0))}%
- Market Cap: ${format_currency(market_data.get('market_cap', 0))}
- Market Rank: #{market_data.get('rank', 'N/A')}
- 24h Volume: ${format_currency(market_data.get('total_volume', 0))}
- Circulating Supply: {format_supply(market_data.get('circulating_supply', 0))}

## AI Analysis
{ai_response}

---
Report generated by AI Crypto Assistant
Disclaimer: This is not financial advice. Always do your own research.
    """.strip()
    
    return content

def validate_api_response(response: dict, required_fields: list) -> bool:
    """Validate API response has required fields"""
    if not isinstance(response, dict):
        return False
    
    for field in required_fields:
        if field not in response:
            return False
    
    return True

def safe_float_conversion(value: Any, default: float = 0.0) -> float:
    """Safely convert value to float"""
    try:
        return float(value) if value is not None else default
    except (ValueError, TypeError):
        return default

def safe_int_conversion(value: Any, default: int = 0) -> int:
    """Safely convert value to int"""
    try:
        return int(value) if value is not None else default
    except (ValueError, TypeError):
        return default

def truncate_text(text: str, max_length: int = 100) -> str:
    """Truncate text to specified length"""
    if len(text) <= max_length:
        return text
    return text[:max_length] + "..."

def format_timestamp(timestamp: str) -> str:
    """Format timestamp for display"""
    try:
        dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
        return dt.strftime("%Y-%m-%d %H:%M")
    except Exception:
        return timestamp

def get_time_ago(timestamp: str) -> str:
    """Get human-readable time ago"""
    try:
        dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
        now = datetime.now(dt.tzinfo)
        diff = now - dt
        
        if diff.days > 0:
            return f"{diff.days} days ago"
        elif diff.seconds > 3600:
            return f"{diff.seconds // 3600} hours ago"
        elif diff.seconds > 60:
            return f"{diff.seconds // 60} minutes ago"
        else:
            return "Just now"
    except Exception:
        return "Unknown"

class SessionStateManager:
    """Manage Streamlit session state"""
    
    @staticmethod
    def initialize_session_state():
        """Initialize session state variables"""
        if 'query_history' not in st.session_state:
            st.session_state.query_history = []
        
        if 'favorite_tokens' not in st.session_state:
            st.session_state.favorite_tokens = []
        
        if 'last_analysis_time' not in st.session_state:
            st.session_state.last_analysis_time = None
    
    @staticmethod
    def add_to_history(query: str, token_info: dict):
        """Add query to history"""
        if 'query_history' not in st.session_state:
            st.session_state.query_history = []
        
        history_item = {
            'query': query,
            'token': token_info,
            'timestamp': datetime.now().isoformat()
        }
        
        st.session_state.query_history.insert(0, history_item)
        
        # Keep only last 10 items
        if len(st.session_state.query_history) > 10:
            st.session_state.query_history = st.session_state.query_history[:10]
    
    @staticmethod
    def add_to_favorites(token_info: dict):
        """Add token to favorites"""
        if 'favorite_tokens' not in st.session_state:
            st.session_state.favorite_tokens = []
        
        # Check if already in favorites
        for fav in st.session_state.favorite_tokens:
            if fav['symbol'] == token_info['symbol']:
                return False
        
        st.session_state.favorite_tokens.append(token_info)
        return True
    
    @staticmethod
    def remove_from_favorites(symbol: str):
        """Remove token from favorites"""
        if 'favorite_tokens' not in st.session_state:
            return
        
        st.session_state.favorite_tokens = [
            fav for fav in st.session_state.favorite_tokens 
            if fav['symbol'] != symbol
        ]